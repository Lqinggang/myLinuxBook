(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{415:function(s,t,a){s.exports=a.p+"assets/img/i2c.d82c5d63.png"},435:function(s,t,a){"use strict";a.r(t);var e=a(2),n=Object(e.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"i2c-设备"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#i2c-设备"}},[s._v("#")]),s._v(" I2C 设备")]),s._v(" "),t("p",[s._v("I2C(内置集成电路) 总线通过时钟线SCL、数据线SDA这两根信号线实现设备之间数据的交互, I2C 总线支持多主控模式, 任何能够进行发送和接收的设备够可以成为主设备, 主控能够控制数据的传输和时钟频率, 在任意时刻只能由一个主控")]),s._v(" "),t("p",[s._v("对于I2C, 为了避免总线信号的混乱, 要求各设备连接到总线的输出端"),t("strong",[s._v("必须是开漏输出或集电极开路输出的结构")])]),s._v(" "),t("p",[t("strong",[s._v("I2C 总线空闲时, 上拉电阻使 SDA 和 SCL 都保持高电平状态")]),s._v(', 根据开漏输出或集电极开路输出信号的"线与"逻辑, I2C 总线上任意器件输出低电平都会使相应总线上的信号线变低')]),s._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"title"},[s._v("说明")]),t("p",[s._v('"线与"逻辑指的是两个或两个以上的输出直接互连就可实现"与"的逻辑功能, 只有输出端是开漏(对于CMOS器件)输出或集电极开路(对于TTL器件)输出时才满足此条件')])]),t("p",[s._v("当 SCL 稳定在高电平时, SDA 由高到低(下降沿)产生一个起始位, 由低到高(上升沿)产生一个停止位, 起始位和停止位都是由I2C主设备产生")]),s._v(" "),t("p",[s._v("在选择从设备时, 如果从设备地址采用 7 位地址格式, 则主设备在发起传输过程前， 需先发送 1 字节的地址信息, 前 7 位为设备地址，最后 1 位为读写标志, 之后, 每次传输的数据也是 1 字节, 从 MSB 开始传输, 每个字节传送完后, 在 SCL 的第 9 个上升沿到来前, 接收方应该发出 1  个 ACK位, SCL 上的时钟脉冲由 I2C 主控方发出, 在第 8 个时钟周期之后, 主控方应该释放 SDA(为了从设备返回 ACK)")]),s._v(" "),t("p",[s._v("如下，是 I2C 总线的时序图, 在编写 I2C 驱动的时候将围绕这个时序图展开(这个图不太准确)")]),s._v(" "),t("p",[t("img",{attrs:{src:a(415),alt:"i2c时序图"}})]),s._v(" "),t("p",[s._v("I2C 驱动由 3 个部分组成, 即 I2C 核心、I2C 总线驱动以及 I2C 设备驱动")]),s._v(" "),t("h2",{attrs:{id:"i2c-核心"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#i2c-核心"}},[s._v("#")]),s._v(" I2C 核心")]),s._v(" "),t("p",[s._v("I2C 核心提供了 I2C 总线驱动和设备驱动的注册、注销方法，I2C 通信方法上层的与具体适配器无关的代码以及探测设备、检测设备地址的上层代码等")]),s._v(" "),t("h2",{attrs:{id:"i2c-总线驱动"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#i2c-总线驱动"}},[s._v("#")]),s._v(" I2C 总线驱动")]),s._v(" "),t("p",[s._v("I2C 总线驱动是对 I2C 硬件体系结构中适配器端的实现，适配器可由 CPU 控制，甚至可直接集成在 CPU 内部")]),s._v(" "),t("p",[s._v("I2C 总线驱动主要包含了 I2C 适配器数据结构 i2c_adapter、I2C 适配器的 Algorithm 数据结构 i2c_algorithm 和控制 I2C 适配器产生通信信号的函数")]),s._v(" "),t("h3",{attrs:{id:"i2c-adapter"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#i2c-adapter"}},[s._v("#")]),s._v(" i2c_adapter")]),s._v(" "),t("div",{staticClass:"language-c extra-class"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*\n * i2c_adapter is the structure used to identify a physical i2c bus along\n * with the access algorithms necessary to access it.\n */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_adapter")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("module")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("owner"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("unsigned")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" class"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("       "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* classes to allow probing for */")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_algorithm")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("algo"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* the algorithm to access the bus */")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("algo_data"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* data fields that are valid for all devices   */")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_lock_operations")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("lock_ops"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("rt_mutex")]),s._v(" bus_lock"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("rt_mutex")]),s._v(" mux_lock"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" timeout"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("            "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* in jiffies */")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" retries"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("device")]),s._v(" dev"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("      "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* the adapter device */")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("unsigned")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("long")]),s._v(" locked_flags"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* owned by the I2C core */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("define")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token macro-name"}},[s._v("I2C_ALF_IS_SUSPENDED")]),s._v("        "),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")])])]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("define")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token macro-name"}},[s._v("I2C_ALF_SUSPEND_REPORTED")]),s._v("    "),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")])])]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" nr"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("char")]),s._v(" name"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("48")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("completion")]),s._v(" dev_released"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("mutex")]),s._v(" userspace_clients_lock"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("list_head")]),s._v(" userspace_clients"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_bus_recovery_info")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("bus_recovery_info"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_adapter_quirks")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("quirks"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("irq_domain")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("host_notify_domain"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("regulator")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("bus_regulator"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("define")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token macro-name function"}},[s._v("to_i2c_adapter")]),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("d"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("container_of")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("d"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_adapter")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" dev"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")])])]),s._v("\n")])])]),t("p",[s._v("如上, 是 i2c 适配器结构体, 其对应于物理上的一个适配器")]),s._v(" "),t("h3",{attrs:{id:"i2c-algorithm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#i2c-algorithm"}},[s._v("#")]),s._v(" i2c_algorithm")]),s._v(" "),t("div",{staticClass:"language-c extra-class"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * struct i2c_algorithm - represent I2C transfer method\n * @master_xfer: Issue a set of i2c transactions to the given I2C adapter\n *   defined by the msgs array, with num messages available to transfer via\n *   the adapter specified by adap.\n * @master_xfer_atomic: same as @master_xfer. Yet, only using atomic context\n *   so e.g. PMICs can be accessed very late before shutdown. Optional.\n * @smbus_xfer: Issue smbus transactions to the given I2C adapter. If this\n *   is not present, then the bus layer will try and convert the SMBus calls\n *   into I2C transfers instead.\n * @smbus_xfer_atomic: same as @smbus_xfer. Yet, only using atomic context\n *   so e.g. PMICs can be accessed very late before shutdown. Optional.\n * @functionality: Return the flags that this algorithm/adapter pair supports\n *   from the ``I2C_FUNC_*`` flags.\n * @reg_slave: Register given client to I2C slave mode of this adapter\n * @unreg_slave: Unregister given client from I2C slave mode of this adapter\n *\n * The following structs are for those who like to implement new bus drivers:\n * i2c_algorithm is the interface to a class of hardware solutions which can\n * be addressed using the same bus algorithms - i.e. bit-banging or the PCF8584\n * to name two of the most common.\n *\n * The return codes from the ``master_xfer{_atomic}`` fields should indicate the\n * type of error code that occurred during the transfer, as documented in the\n * Kernel Documentation file Documentation/i2c/fault-codes.rst. Otherwise, the\n * number of messages executed should be returned.\n */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_algorithm")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*\n     * If an adapter algorithm can't do I2C-level access, set master_xfer\n     * to NULL. If an adapter algorithm can do SMBus access, set\n     * smbus_xfer. If set to NULL, the SMBus protocol is simulated\n     * using common I2C messages.\n     *\n     * master_xfer should return the number of messages successfully\n     * processed, or a negative value on error\n     */")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("master_xfer"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_adapter")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("adap"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_msg")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("msgs"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" num"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* 用于产生I2C访问周期需要的信号 */")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("master_xfer_atomic"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_adapter")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("adap"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_msg")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("msgs"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" num"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("smbus_xfer"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_adapter")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("adap"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" u16 addr"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("unsigned")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("short")]),s._v(" flags"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("char")]),s._v(" read_write"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" u8 command"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" size"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("union")]),s._v(" i2c_smbus_data "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("data"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("smbus_xfer_atomic"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_adapter")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("adap"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" u16 addr"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("unsigned")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("short")]),s._v(" flags"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("char")]),s._v(" read_write"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* To determine what the adapter supports */")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("u32")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("functionality"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_adapter")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("adap"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("if")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token function"}},[s._v("IS_ENABLED")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("CONFIG_I2C_SLAVE"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")])])]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("reg_slave"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_client")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("client"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("unreg_slave"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_client")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("client"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("endif")])]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("p",[s._v("如上, 是 i2c_algorithm  结构体，I2C 适配器通过 i2c_algorithm 提供的通信函数来控制适配器产生特定的访问周期")]),s._v(" "),t("h3",{attrs:{id:"i2c-msg"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#i2c-msg"}},[s._v("#")]),s._v(" i2c_msg")]),s._v(" "),t("div",{staticClass:"language-c extra-class"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v('/**\n * struct i2c_msg - an I2C transaction segment beginning with START\n *\n * @addr: Slave address, either 7 or 10 bits. When this is a 10 bit address,\n *   %I2C_M_TEN must be set in @flags and the adapter must support\n *   %I2C_FUNC_10BIT_ADDR.\n *\n * @flags:\n *   Supported by all adapters:\n *   %I2C_M_RD: read data (from slave to master). Guaranteed to be 0x0001!\n *\n *   Optional:\n *   %I2C_M_DMA_SAFE: the buffer of this message is DMA safe. Makes only sense\n *     in kernelspace, because userspace buffers are copied anyway\n *\n *   Only if I2C_FUNC_10BIT_ADDR is set:\n *   %I2C_M_TEN: this is a 10 bit chip address\n *\n *   Only if I2C_FUNC_SMBUS_READ_BLOCK_DATA is set:\n *   %I2C_M_RECV_LEN: message length will be first received byte\n *\n *   Only if I2C_FUNC_NOSTART is set:\n *   %I2C_M_NOSTART: skip repeated start sequence\n\n *   Only if I2C_FUNC_PROTOCOL_MANGLING is set:\n *   %I2C_M_NO_RD_ACK: in a read message, master ACK/NACK bit is skipped\n *   %I2C_M_IGNORE_NAK: treat NACK from client as ACK\n *   %I2C_M_REV_DIR_ADDR: toggles the Rd/Wr bit\n *   %I2C_M_STOP: force a STOP condition after the message\n *\n * @len: Number of data bytes in @buf being read from or written to the I2C\n *   slave address. For read transactions where %I2C_M_RECV_LEN is set, the\n *   caller guarantees that this buffer can hold up to %I2C_SMBUS_BLOCK_MAX\n *   bytes in addition to the initial length byte sent by the slave (plus,\n *   if used, the SMBus PEC); and this value will be incremented by the number\n *   of block data bytes received.\n *\n * @buf: The buffer into which data is read, or from which it\'s written.\n *\n * An i2c_msg is the low level representation of one segment of an I2C\n * transaction.  It is visible to drivers in the @i2c_transfer() procedure,\n * to userspace from i2c-dev, and to I2C adapter drivers through the\n * @i2c_adapter.@master_xfer() method.\n *\n * Except when I2C "protocol mangling" is used, all I2C adapters implement\n * the standard rules for I2C transactions.  Each transaction begins with a\n * START.  That is followed by the slave address, and a bit encoding read\n * versus write.  Then follow all the data bytes, possibly including a byte\n * with SMBus PEC.  The transfer terminates with a NAK, or when all those\n * bytes have been transferred and ACKed.  If this is the last message in a\n * group, it is followed by a STOP.  Otherwise it is followed by the next\n * @i2c_msg transaction segment, beginning with a (repeated) START.\n *\n * Alternatively, when the adapter supports %I2C_FUNC_PROTOCOL_MANGLING then\n * passing certain @flags may have changed those standard protocol behaviors.\n * Those flags are only for use with broken/nonconforming slaves, and with\n * adapters which are known to support the specific mangling options they need.\n */')]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_msg")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    __u16 addr"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    __u16 flags"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("define")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token macro-name"}},[s._v("I2C_M_RD")]),s._v("        "),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0x0001")]),s._v("  ")]),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* guaranteed to be 0x0001! */")])]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("define")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token macro-name"}},[s._v("I2C_M_TEN")]),s._v("       "),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0x0010")]),s._v("  ")]),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* use only if I2C_FUNC_10BIT_ADDR */")])]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("define")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token macro-name"}},[s._v("I2C_M_DMA_SAFE")]),s._v("      "),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0x0200")]),s._v("  ")]),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* use only in kernel space */")])]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("define")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token macro-name"}},[s._v("I2C_M_RECV_LEN")]),s._v("      "),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0x0400")]),s._v("  ")]),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* use only if I2C_FUNC_SMBUS_READ_BLOCK_DATA */")])]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("define")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token macro-name"}},[s._v("I2C_M_NO_RD_ACK")]),s._v("     "),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0x0800")]),s._v("  ")]),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* use only if I2C_FUNC_PROTOCOL_MANGLING */")])]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("define")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token macro-name"}},[s._v("I2C_M_IGNORE_NAK")]),s._v("    "),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0x1000")]),s._v("  ")]),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* use only if I2C_FUNC_PROTOCOL_MANGLING */")])]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("define")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token macro-name"}},[s._v("I2C_M_REV_DIR_ADDR")]),s._v("  "),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0x2000")]),s._v("  ")]),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* use only if I2C_FUNC_PROTOCOL_MANGLING */")])]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("define")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token macro-name"}},[s._v("I2C_M_NOSTART")]),s._v("       "),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0x4000")]),s._v("  ")]),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* use only if I2C_FUNC_NOSTART */")])]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("define")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token macro-name"}},[s._v("I2C_M_STOP")]),s._v("      "),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0x8000")]),s._v("  ")]),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* use only if I2C_FUNC_PROTOCOL_MANGLING */")])]),s._v("\n    __u16 len"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    __u8 "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("buf"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("p",[s._v("如上， 是 i2c 消息结构体, i2c 核心中, 通过收发该结构体数据来完成 i2c 设备间数据的交互")]),s._v(" "),t("h2",{attrs:{id:"i2c-设备驱动"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#i2c-设备驱动"}},[s._v("#")]),s._v(" I2C 设备驱动")]),s._v(" "),t("p",[s._v("I2C 设备驱动是对 I2C 硬件体系结构中设备端的实现，设备一般挂接在受 CPU 控制的 I2C 适配器上, 通过 I2C 适配器与 CPU 交换数据")]),s._v(" "),t("p",[s._v("I2C 设备驱动主要包含 i2c_driver 和 i2c_client")]),s._v(" "),t("h3",{attrs:{id:"i2c-driver"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#i2c-driver"}},[s._v("#")]),s._v(" i2c_driver")]),s._v(" "),t("div",{staticClass:"language-c extra-class"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * struct i2c_driver - represent an I2C device driver\n * @class: What kind of i2c device we instantiate (for detect)\n * @probe: Callback for device binding\n * @remove: Callback for device unbinding\n * @shutdown: Callback for device shutdown\n * @alert: Alert callback, for example for the SMBus alert protocol\n * @command: Callback for bus-wide signaling (optional)\n * @driver: Device driver model driver\n * @id_table: List of I2C devices supported by this driver\n * @detect: Callback for device detection\n * @address_list: The I2C addresses to probe (for detect)\n * @clients: List of detected clients we created (for i2c-core use only)\n * @flags: A bitmask of flags defined in &enum i2c_driver_flags\n *\n * The driver.owner field should be set to the module owner of this driver.\n * The driver.name field should be set to the name of this driver.\n *\n * For automatic device detection, both @detect and @address_list must\n * be defined. @class should also be set, otherwise only devices forced\n * with module parameters will be created. The detect function must\n * fill at least the name field of the i2c_board_info structure it is\n * handed upon successful detection, and possibly also the flags field.\n *\n * If @detect is missing, the driver will still work fine for enumerated\n * devices. Detected devices simply won't be supported. This is expected\n * for the many I2C/SMBus devices which can't be detected reliably, and\n * the ones which can always be enumerated in practice.\n *\n * The i2c_client structure which is handed to the @detect callback is\n * not a real i2c_client. It is initialized just enough so that you can\n * call i2c_smbus_read_byte_data and friends on it. Don't do anything\n * else with it. In particular, calling dev_dbg and friends on it is\n * not allowed.\n */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_driver")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("unsigned")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" class"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* Standard driver model interfaces */")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("probe"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_client")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("client"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("remove"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_client")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("client"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* driver model interfaces that don't relate to enumeration  */")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("shutdown"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_client")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("client"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v('/* Alert callback, for example for the SMBus alert protocol.\n     * The format and meaning of the data value depends on the protocol.\n     * For the SMBus alert protocol, there is a single bit of data passed\n     * as the alert response\'s low bit ("event flag").\n     * For the SMBus Host Notify protocol, the data corresponds to the\n     * 16-bit payload data reported by the slave device acting as master.\n     */')]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("alert"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_client")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("client"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("enum")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_alert_protocol")]),s._v(" protocol"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n              "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("unsigned")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" data"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* a ioctl like command that can be used to perform specific functions\n     * with the device.\n     */")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("command"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_client")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("client"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("unsigned")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" cmd"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("arg"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("device_driver")]),s._v(" driver"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_device_id")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("id_table"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* Device detection callback for automatic device creation */")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("detect"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_client")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("client"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_board_info")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("info"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("unsigned")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("short")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("address_list"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("list_head")]),s._v(" clients"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    u32 flags"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("define")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token macro-name function"}},[s._v("to_i2c_driver")]),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("d"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("container_of")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("d"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_driver")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" driver"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")])])]),s._v("\n")])])]),t("p",[s._v("如上, 是 I2C 驱动结构体")]),s._v(" "),t("h3",{attrs:{id:"i2c-client"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#i2c-client"}},[s._v("#")]),s._v(" i2c_client")]),s._v(" "),t("div",{staticClass:"language-c extra-class"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * struct i2c_client - represent an I2C slave device\n * @flags: see I2C_CLIENT_* for possible flags\n * @addr: Address used on the I2C bus connected to the parent adapter.\n * @name: Indicates the type of the device, usually a chip name that's\n *  generic enough to hide second-sourcing and compatible revisions.\n * @adapter: manages the bus segment hosting this I2C device\n * @dev: Driver model device node for the slave.\n * @init_irq: IRQ that was set at initialization\n * @irq: indicates the IRQ generated by this device (if any)\n * @detected: member of an i2c_driver.clients list or i2c-core's\n *  userspace_devices list\n * @slave_cb: Callback when I2C slave mode of an adapter is used. The adapter\n *  calls it to pass on slave events to the slave driver.\n * @devres_group_id: id of the devres group that will be created for resources\n *  acquired when probing this device.\n *\n * An i2c_client identifies a single device (i.e. chip) connected to an\n * i2c bus. The behaviour exposed to Linux is defined by the driver\n * managing the device.\n */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_client")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("unsigned")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("short")]),s._v(" flags"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("       "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* div., see below      */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("define")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token macro-name"}},[s._v("I2C_CLIENT_PEC")]),s._v("      "),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0x04")]),s._v("    ")]),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* Use Packet Error Checking */")])]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("define")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token macro-name"}},[s._v("I2C_CLIENT_TEN")]),s._v("      "),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0x10")]),s._v("    ")]),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* we have a ten bit chip address */")])]),s._v("\n                    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* Must equal I2C_M_TEN below */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("define")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token macro-name"}},[s._v("I2C_CLIENT_SLAVE")]),s._v("    "),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0x20")]),s._v("    ")]),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* we are the slave */")])]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("define")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token macro-name"}},[s._v("I2C_CLIENT_HOST_NOTIFY")]),s._v("  "),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0x40")]),s._v("    ")]),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* We want to use I2C host notify */")])]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("define")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token macro-name"}},[s._v("I2C_CLIENT_WAKE")]),s._v("     "),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0x80")]),s._v("    ")]),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* for board_info; true iff can wake */")])]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("define")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token macro-name"}},[s._v("I2C_CLIENT_SCCB")]),s._v("     "),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0x9000")]),s._v("  ")]),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* Use Omnivision SCCB protocol */")])]),s._v("\n                    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* Must match I2C_M_STOP|IGNORE_NAK */")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("unsigned")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("short")]),s._v(" addr"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("        "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* chip address - NOTE: 7bit    */")]),s._v("\n                    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* addresses are stored in the  */")]),s._v("\n                    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* _LOWER_ 7 bits       */")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("char")]),s._v(" name"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("I2C_NAME_SIZE"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_adapter")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("adapter"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* the adapter we sit on    */")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("device")]),s._v(" dev"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("      "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* the device structure     */")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" init_irq"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("           "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* irq set at initialization    */")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" irq"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("            "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* irq issued by device     */")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("list_head")]),s._v(" detected"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("if")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token function"}},[s._v("IS_ENABLED")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("CONFIG_I2C_SLAVE"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")])])]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_slave_cb_t")]),s._v(" slave_cb"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* callback for slave mode  */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("endif")])]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("devres_group_id"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("      "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* ID of probe devres group */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[t("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("define")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token macro-name function"}},[s._v("to_i2c_client")]),t("span",{pre:!0,attrs:{class:"token expression"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("d"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("container_of")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("d"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("i2c_client")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" dev"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")])])]),s._v("\n")])])]),t("p",[s._v("如上, i2c_client 对应于真实的物理设备, 每个 I2C 设备都需要一个 i2c_client 来描述, 一个 i2c_client 依附于 i2c_adapter")]),s._v(" "),t("h2",{attrs:{id:"i2c-驱动实现的主要工作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#i2c-驱动实现的主要工作"}},[s._v("#")]),s._v(" I2C 驱动实现的主要工作")]),s._v(" "),t("ol",[t("li",[t("p",[s._v("提供 I2C 适配器的硬件驱动，探测、初始化 I2C 适配器、驱动 CPU 控制的 I2C 适配器从硬件上产生各种信号以及处理 I2C 中断等")])]),s._v(" "),t("li",[t("p",[s._v("提供 I2C 适配器的 algorightm。 用于具体适配器的 xxx_xfer() 函数填充 i2c_algorithm 的 master_xfer 指针，并把 i2c_algorithm 指针赋值给 i2c_adapter 的 algo 指针")])]),s._v(" "),t("li",[t("p",[s._v("实现 I2C 设备驱动中 i2c_driver 接口。 用具体设备探测(probe)、移除(remove)、挂起(suspend)和恢复(resume)的函数指针和 i2c_device_id 设备 ID 表赋值给 i2c_driver 的 probe、remove、suspend、resume和 id_table 指针")])]),s._v(" "),t("li",[t("p",[s._v("实现 I2C 设备所对应类型的具体驱动。i2c_driver 只是实现设备与总线的挂接")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);