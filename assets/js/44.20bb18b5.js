(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{432:function(t,s,a){"use strict";a.r(s);var n=a(2),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"设备树-device-tree"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设备树-device-tree"}},[t._v("#")]),t._v(" 设备树(Device Tree)")]),t._v(" "),s("h2",{attrs:{id:"简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),s("p",[t._v("设备树(Device Tree), 描述设备树的文件叫做DTS(Device Tree Source), 用于描述板级设备信息, 可以理解为物理设备的一种描述, 总结?")]),t._v(" "),s("p",[t._v("设备树是一种描述硬件的数据结构, 由一系列被命名的节点(Node)和属性(Property)组成, 节点本身也可以包含字节点, 属性即成对出现的名称和值")]),t._v(" "),s("p",[t._v("以下将要介绍的关于设备树的全部内容将基于 ARM 设备, ARM Linux 是在 3.x 中引入设备树的")]),t._v(" "),s("h3",{attrs:{id:"dts-device-tree-source"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dts-device-tree-source"}},[t._v("#")]),t._v(" DTS(Device Tree Source)")]),t._v(" "),s("p",[t._v(".dts 文件是一种 ASCII 文本格式的设备树描述文件，.dtsi 文件包含 SoC 公用的部分或多个设备共同的部分, 类似与 c 语言中的头文件, 在 .dts 文件中可以通过 include 的方式包含进来:")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('#include "xxxxx.dtsi"\n')])])]),s("p",[t._v("dts 文件的编译过程支持 c 的预处理, 所以在 .dts 文件中可以通过 include 将 c 中的头文件包含进来, 比如:")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<dt-bindings/gpio/gpio.h>")])]),t._v("\n")])])]),s("h3",{attrs:{id:"dtc-device-tree-compiler"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dtc-device-tree-compiler"}},[t._v("#")]),t._v(" DTC(Device Tree Compiler)")]),t._v(" "),s("p",[t._v("DTC 是将 .dts 文件编译为 .dtb 的工具")]),t._v(" "),s("h3",{attrs:{id:"dtb-device-tree-blob"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dtb-device-tree-blob"}},[t._v("#")]),t._v(" DTB(Device Tree Blob)")]),t._v(" "),s("p",[t._v(".dtb 是 .dts 被 DTC 编译之后生成的二进制格式的设备描述文件, 可由内核解析。")]),t._v(" "),s("h2",{attrs:{id:"设备树节点-语法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设备树节点-语法"}},[t._v("#")]),t._v(" 设备树节点/语法")]),t._v(" "),s("p",[t._v("如下, 是Linux 6.6 中包含的树莓派4B 的 dts 文件(bcm2711-rpi-4-b.dts), 本章节将以其作为示例讲解设备树节点")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('// SPDX-License-Identifier: GPL-2.0\n/dts-v1/;\n#include "bcm2711.dtsi"\n#include "bcm2711-rpi.dtsi"\n#include "bcm283x-rpi-led-deprecated.dtsi"\n#include "bcm283x-rpi-usb-peripheral.dtsi"\n#include "bcm283x-rpi-wifi-bt.dtsi"\n\n/ {\n\tcompatible = "raspberrypi,4-model-b", "brcm,bcm2711";\n\tmodel = "Raspberry Pi 4 Model B";\n\n\tchosen {\n\t\t/* 8250 auxiliary UART instead of pl011 */\n\t\tstdout-path = "serial1:115200n8";\n\t};\n\n\tsd_io_1v8_reg: regulator-sd-io-1v8 {\n\t\tcompatible = "regulator-gpio";\n\t\tregulator-name = "vdd-sd-io";\n\t\tregulator-min-microvolt = <1800000>;\n\t\tregulator-max-microvolt = <3300000>;\n\t\tregulator-boot-on;\n\t\tregulator-always-on;\n\t\tregulator-settling-time-us = <5000>;\n\t\tgpios = <&expgpio 4 GPIO_ACTIVE_HIGH>;\n\t\tstates = <1800000 0x1>,\n\t\t\t <3300000 0x0>;\n\t\tstatus = "okay";\n\t};\n\n\tsd_vcc_reg: regulator-sd-vcc {\n\t\tcompatible = "regulator-fixed";\n\t\tregulator-name = "vcc-sd";\n\t\tregulator-min-microvolt = <3300000>;\n\t\tregulator-max-microvolt = <3300000>;\n\t\tregulator-boot-on;\n\t\tenable-active-high;\n\t\tgpio = <&expgpio 6 GPIO_ACTIVE_HIGH>;\n\t};\n};\n\n&bt {\n\tshutdown-gpios = <&expgpio 0 GPIO_ACTIVE_HIGH>;\n};\n\n&ddc0 {\n\tstatus = "okay";\n};\n\n&ddc1 {\n\tstatus = "okay";\n};\n\n&expgpio {\n\tgpio-line-names = "BT_ON",\t\t/*  0 */\n\t\t\t  "WL_ON",\n\t\t\t  "PWR_LED_OFF",\n\t\t\t  "GLOBAL_RESET",\n\t\t\t  "VDD_SD_IO_SEL",\n\t\t\t  "CAM_GPIO",\t\t/*  5 */\n\t\t\t  "SD_PWR_ON",\n\t\t\t  "";\n};\n\n&gpio {\n\t/*\n\t * Parts taken from rpi_SCH_4b_4p0_reduced.pdf and\n\t * the official GPU firmware DT blob.\n\t *\n\t * Legend:\n\t * "FOO" = GPIO line named "FOO" on the schematic\n\t * "FOO_N" = GPIO line named "FOO" on schematic, active low\n\t */\n\tgpio-line-names = "ID_SDA",\t\t/*  0 */\n\t\t\t  "ID_SCL",\n\t\t\t  "SDA1",\n\t\t\t  "SCL1",\n\t\t\t  "GPIO_GCLK",\n\t\t\t  "GPIO5",\t\t/*  5 */\n\t\t\t  "GPIO6",\n\t\t\t  "SPI_CE1_N",\n\t\t\t  "SPI_CE0_N",\n\t\t\t  "SPI_MISO",\n\t\t\t  "SPI_MOSI",\t\t/* 10 */\n\t\t\t  "SPI_SCLK",\n\t\t\t  "GPIO12",\n\t\t\t  "GPIO13",\n\t\t\t  /* Serial port */\n\t\t\t  "TXD1",\n\t\t\t  "RXD1",\t\t/* 15 */\n\t\t\t  "GPIO16",\n\t\t\t  "GPIO17",\n\t\t\t  "GPIO18",\n\t\t\t  "GPIO19",\n\t\t\t  "GPIO20",\t\t/* 20 */\n\t\t\t  "GPIO21",\n\t\t\t  "GPIO22",\n\t\t\t  "GPIO23",\n\t\t\t  "GPIO24",\n\t\t\t  "GPIO25",\t\t/* 25 */\n\t\t\t  "GPIO26",\n\t\t\t  "GPIO27",\n\t\t\t  "RGMII_MDIO",\n\t\t\t  "RGMIO_MDC",\n\t\t\t  /* Used by BT module */\n\t\t\t  "CTS0",\t\t/* 30 */\n\t\t\t  "RTS0",\n\t\t\t  "TXD0",\n\t\t\t  "RXD0",\n\t\t\t  /* Used by Wifi */\n\t\t\t  "SD1_CLK",\n\t\t\t  "SD1_CMD",\t\t/* 35 */\n\t\t\t  "SD1_DATA0",\n\t\t\t  "SD1_DATA1",\n\t\t\t  "SD1_DATA2",\n\t\t\t  "SD1_DATA3",\n\t\t\t  /* Shared with SPI flash */\n\t\t\t  "PWM0_MISO",\t\t/* 40 */\n\t\t\t  "PWM1_MOSI",\n\t\t\t  "STATUS_LED_G_CLK",\n\t\t\t  "SPIFLASH_CE_N",\n\t\t\t  "SDA0",\n\t\t\t  "SCL0",\t\t/* 45 */\n\t\t\t  "RGMII_RXCLK",\n\t\t\t  "RGMII_RXCTL",\n\t\t\t  "RGMII_RXD0",\n\t\t\t  "RGMII_RXD1",\n\t\t\t  "RGMII_RXD2",\t\t/* 50 */\n\t\t\t  "RGMII_RXD3",\n\t\t\t  "RGMII_TXCLK",\n\t\t\t  "RGMII_TXCTL",\n\t\t\t  "RGMII_TXD0",\n\t\t\t  "RGMII_TXD1",\t\t/* 55 */\n\t\t\t  "RGMII_TXD2",\n\t\t\t  "RGMII_TXD3";\n};\n\n&hdmi0 {\n\tstatus = "okay";\n};\n\n&hdmi1 {\n\tstatus = "okay";\n};\n\n&led_act {\n\tgpios = <&gpio 42 GPIO_ACTIVE_HIGH>;\n};\n\n&leds {\n\tled_pwr: led-pwr {\n\t\tlabel = "PWR";\n\t\tgpios = <&expgpio 2 GPIO_ACTIVE_LOW>;\n\t\tdefault-state = "keep";\n\t\tlinux,default-trigger = "default-on";\n\t};\n};\n\n&pixelvalve0 {\n\tstatus = "okay";\n};\n\n&pixelvalve1 {\n\tstatus = "okay";\n};\n\n&pixelvalve2 {\n\tstatus = "okay";\n};\n\n&pixelvalve4 {\n\tstatus = "okay";\n};\n\n&pwm1 {\n\tpinctrl-names = "default";\n\tpinctrl-0 = <&pwm1_0_gpio40 &pwm1_1_gpio41>;\n\tstatus = "okay";\n};\n\n/* EMMC2 is used to drive the SD card */\n&emmc2 {\n\tvqmmc-supply = <&sd_io_1v8_reg>;\n\tvmmc-supply = <&sd_vcc_reg>;\n\tbroken-cd;\n\tstatus = "okay";\n};\n\n&genet {\n\tphy-handle = <&phy1>;\n\tphy-mode = "rgmii-rxid";\n\tstatus = "okay";\n};\n\n&genet_mdio {\n\tphy1: ethernet-phy@1 {\n\t\t/* No PHY interrupt */\n\t\treg = <0x1>;\n\t};\n};\n\n&pcie0 {\n\tpci@0,0 {\n\t\tdevice_type = "pci";\n\t\t#address-cells = <3>;\n\t\t#size-cells = <2>;\n\t\tranges;\n\n\t\treg = <0 0 0 0 0>;\n\n\t\tusb@0,0 {\n\t\t\treg = <0 0 0 0 0>;\n\t\t\tresets = <&reset RASPBERRYPI_FIRMWARE_RESET_ID_USB>;\n\t\t};\n\t};\n};\n\n/* uart0 communicates with the BT module */\n&uart0 {\n\tpinctrl-names = "default";\n\tpinctrl-0 = <&uart0_ctsrts_gpio30 &uart0_gpio32>;\n\tuart-has-rtscts;\n};\n\n/* uart1 is mapped to the pin header */\n&uart1 {\n\tpinctrl-names = "default";\n\tpinctrl-0 = <&uart1_gpio14>;\n\tstatus = "okay";\n};\n\n&vc4 {\n\tstatus = "okay";\n};\n\n&vec {\n\tstatus = "disabled";\n};\n\n&wifi_pwrseq {\n\treset-gpios = <&expgpio 1 GPIO_ACTIVE_LOW>;\n};\n')])])]),s("h3",{attrs:{id:"根节点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#根节点"}},[t._v("#")]),t._v(" 根节点")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("/ {\n};\n")])])]),s("p",[t._v("根节点, 在所有的设备树中都包含由一个根节点, 用于表示设备树描述的起始点")]),t._v(" "),s("h3",{attrs:{id:"兼容性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#兼容性"}},[t._v("#")]),t._v(" 兼容性")]),t._v(" "),s("div",{attrs:{id:"compatible"}}),t._v(" "),s("p",[t._v("dts 中使用 "),s("code",[t._v("compatible")]),t._v(" 来表示兼容属性, 设备驱动会根据 "),s("code",[t._v("struct device_driver")]),t._v(" 数据结构中的 "),s("code",[t._v("of_match_table")]),t._v(" 成员对应的兼容性匹配表匹配设备")]),t._v(" "),s("h4",{attrs:{id:"根节点兼容性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#根节点兼容性"}},[t._v("#")]),t._v(" 根节点兼容性")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('\tcompatible = "raspberrypi,4-model-b", "brcm,bcm2711";\n')])])]),s("p",[t._v("如上, 是在 '/' 根节点下, 对应的就是 '/' 的兼容属性， 根节点 '/' 的兼容属性可判断启动的是什么设备, 一般而言, 第一个属性值是板子级别的属性, 后一个属性值是芯片级别(或者芯片系列级别)的属性, 兼容属性值按先后属性表示范围依次扩大")]),t._v(" "),s("p",[t._v("这里, 第一个属性值表示的是这份 dts 文件作用于树莓派 4B 这块板子, 后一个属性值表示这份 dts 文件也兼容 bcm2711 芯片，作为对比，以下是树莓派400的 dts 文件, 和树莓派4B比较, 可以发现, 只有第一个属性值一样(这两个用的都是 bcm2711 的芯片)")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('    compatible = "raspberrypi,400", "brcm,bcm2711";\n')])])]),s("p",[s("code",[t._v("compatible")]),t._v(" 兼容属性也可以包含两个以上的情况, 如下 broadcom/bcm953012hr.dts 文件中定义的：")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('    compatible = "brcm,bcm953012hr", "brcm,bcm53012", "brcm,bcm4708";\n')])])]),s("p",[t._v("此时, 第一个属性值依然表示板子级别的属性, 第二个属性值是特定芯片级别属性, 第三个属性是芯片系列级别属性")]),t._v(" "),s("p",[t._v("在 Linux 内核中, 通过 "),s("a",{attrs:{href:"#of_machine_is_compatible"}},[t._v("of_machine_is_compatible")]),t._v(" 来判断根节点兼容性")]),t._v(" "),s("h4",{attrs:{id:"设备节点兼容性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设备节点兼容性"}},[t._v("#")]),t._v(" 设备节点兼容性")]),t._v(" "),s("p",[t._v("除了根节点兼容性之外, 在 .dts 文件中的每个设备节点都可以有一个兼容属性:")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('\tsd_io_1v8_reg: regulator-sd-io-1v8 {\n\t\tcompatible = "regulator-gpio";\n    };\n')])])]),s("p",[t._v("如上, 在树莓派4B 中, regulator-sd-io-1v8 设备节点就有一个设备节点兼容性, 与根节点兼容性类似, 兼容属性列表越往后代表的兼容范围越大")]),t._v(" "),s("p",[t._v("一般而言，设备节点兼容性是第一个兼容性值表示节点代表的确切设备, 形式为 "),s("code",[t._v("<manufacturer>,<model>")]),t._v("， 其后的兼容性值表示可以兼容的其他设备")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('        uart2: serial@7e201400 {\n            compatible = "arm,pl011", "arm,primecell";\n        };\n')])])]),s("p",[t._v('如上, 是 bcm2711.dtsi 中 uart2 对应的节点兼容性, 第一个属性值为 "arm,pl011", 表示，这个节点可以兼容 manufacturer 为 arm, model 为 pl011 的设备, 后续兼容性依次类推')]),t._v(" "),s("p",[t._v("在 Linux 内核中, 通过 "),s("a",{attrs:{href:"#of_device_compatible_match"}},[t._v("of_device_is_compatible")]),t._v(" 来判断设备节点兼容性")]),t._v(" "),s("h3",{attrs:{id:"cpu-设备节点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cpu-设备节点"}},[t._v("#")]),t._v(" CPU 设备节点")]),t._v(" "),s("p",[t._v("cpus 用于描述此设备上的 cpu")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('    cpus: cpus {\n        #address-cells = <1>;\n        #size-cells = <0>;\n        enable-method = "brcm,bcm2836-smp"; // for ARM 32-bit\n\n        /* Source for d/i-cache-line-size and d/i-cache-sets\n         * https://developer.arm.com/documentation/100095/0003\n         * /Level-1-Memory-System/About-the-L1-memory-system?lang=en\n         * Source for d/i-cache-size\n         * https://www.raspberrypi.com/documentation/computers\n         * /processors.html#bcm2711\n         */\n        cpu0: cpu@0 {\n            device_type = "cpu";\n            compatible = "arm,cortex-a72";\n            reg = <0>;\n            enable-method = "spin-table";\n            cpu-release-addr = <0x0 0x000000d8>;\n            d-cache-size = <0x8000>;\n            d-cache-line-size = <64>;\n            d-cache-sets = <256>; // 32KiB(size)/64(line-size)=512ways/2-way set\n            i-cache-size = <0xc000>;\n            i-cache-line-size = <64>;\n            i-cache-sets = <256>; // 48KiB(size)/64(line-size)=768ways/3-way set\n            next-level-cache = <&l2>;\n        };\n    };\n')])])]),s("p",[t._v("如上, 是在 bcm2711.dtsi 文件中, 截取的 cpus 设备节点部分内容, 这里不难看出 cpu 也有自己的"),s("a",{attrs:{href:"#compatible"}},[t._v("兼容性属性")]),t._v(", 在 bcm2711.dtsi 中, 一共描述出来了 4 个 cpu (bcm2711芯片是4个 cortex-a72 核)")]),t._v(" "),s("p",[t._v("注意，这里的"),s("code",[t._v("cpus: cpus")]),t._v("和"),s("code",[t._v("cpu0: cpu0@0")]),t._v("表示形式, 它们遵循的组织形式为 "),s("code",[t._v("[label: ]<name>[@<unit-address>]")]),t._v(", 其中 label 和 unit-address 都是可选的, name 表示节点对应的设备类型, 多个相同类型设备节点的 name 值可以一样, 只要保证 unit-address 不同即可, 如bcm2711.dtsi 文件中,")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("    cpus: cpus {\n        cpu0: cpu@0 {\n        };\n        cpu1: cpu@1 {\n        };\n        cpu2: cpu@2 {\n        };\n        cpu3: cpu@3 {\n        };\n    };\n")])])]),s("p",[t._v("它们对应的 name 都是相同, 但是 unit-address 不同")]),t._v(" "),s("p",[t._v("对于挂载在内存空间的设备而言, @字符后跟的一般就是该设备在内存空间的基地址, 如")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('        pcie0: pcie@7d500000 {\n            compatible = "brcm,bcm2711-pcie";\n            reg = <0x0 0x7d500000 0x9310>;\n        };\n')])])]),s("p",[t._v("对于挂载在总线上的外设而言, @字符后跟的一般是从设备的地址, 如")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('        i2c3: i2c@7e205600 {\n            compatible = "brcm,bcm2711-i2c", "brcm,bcm2835-i2c";\n            reg = <0x7e205600 0x200>;\n        };\n')])])]),s("h3",{attrs:{id:"标签"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标签"}},[t._v("#")]),t._v(" 标签")]),t._v(" "),s("p",[t._v("在定义一个设备节点的时候, 经常也同时定义一个 label, label 的命名一般形式为 '<设备类型><index>', 如前面所述的cpu0, cpu1等即为一个label, label定义形式为: "),s("code",[t._v("[label:]<name>[@<unit-address>]")])]),t._v(" "),s("p",[t._v("在定义之后, 可以通过 &label 的形式引用这个 label, 这种引用是通过phandle(pointer handle)进行的")]),t._v(" "),s("p",[t._v("如示例中的 sd_vcc_reg")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("/ {\n\tsd_vcc_reg: regulator-sd-vcc {\n\t};\n};\n&emmc2 {\n\tvmmc-supply = <&sd_vcc_reg>;\n};\n\n")])])]),s("h3",{attrs:{id:"地址编码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#地址编码"}},[t._v("#")]),t._v(" 地址编码")]),t._v(" "),s("p",[t._v("在设备树中, 可寻址设备可以使用如下信息对地址进行编码")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("reg\n#address-cells\n#size-cells\n")])])]),s("p",[t._v("reg 的组织形式为 "),s("code",[t._v("reg = <address0 length0 [address1 length1] [address2 length2] ...>")]),t._v(", 其中的每组"),s("code",[t._v("address length")]),t._v("表明了设备使用的一个地址范围， address 为1个或多个32位的整型(即cell), length 表示address地址范围长度, 即表示共 "),s("code",[t._v("length")]),t._v(" 个地址: "),s("code",[t._v("[address, address + length - 1]")])]),t._v(" "),s("p",[t._v("reg 中的 address 和 length 字段是可变长的, 其由父节点控制, 父节点的 #address-cells 和 #size-cells 分别决定子字节点 reg 属性的 address 和 length 字段的长度(或者元素个数)")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('    cpus: cpus {\n        #address-cells = <1>;\n        #size-cells = <0>;\n\n        cpu0: cpu@0 {\n            device_type = "cpu";\n            compatible = "arm,cortex-a72";\n            reg = <0>;\n        };\n    }\n\n')])])]),s("p",[t._v("如上,  #address-cells = <1> 和 #size-cells = <0>, 分别表示子节点的address 为1, length 字段为0, 所以在 cpu0 中, "),s("code",[t._v("reg = <0>")]),t._v(" 只有一个 address, 且其值为 0")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("&pcie0 {\n\tpci@0,0 {\n\t\t#address-cells = <3>;\n\t\t#size-cells = <2>;\n\t\tusb@0,0 {\n\t\t\treg = <0 1 2 3 4>;\n\t\t};\n\t};\n};\n")])])]),s("p",[t._v("如上,  #address-cells = <3> 和 #size-cells = <2>, 分别表示子节点的address 为3 个元素, length 字段为2 个元素, 所以子节点 usb 中, "),s("code",[t._v("reg = <0 1 2 3 4>")]),t._v(", address 等于 "),s("code",[t._v("0 1 2")]),t._v(", length 等于 "),s("code",[t._v("3 4")])]),t._v(" "),s("h3",{attrs:{id:"地址转换表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#地址转换表"}},[t._v("#")]),t._v(" 地址转换表")]),t._v(" "),s("p",[t._v("地址转换表用 ranges 属性来表示, 其中的每个项目是一个子地址、父地址以及在子地址空间的大小的映射，映射表中的子地址、父地址分别采用子地址空间的 #address-cells 和父地址空间的 #address-cells 的大小")]),t._v(" "),s("p",[t._v("如下是在 bcm-nsp.dtsi 文件中 mpcore-bus 设备节点中包含的 ranges 属性的定义")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('/ {\n    #address-cells = <1>;\n    #size-cells = <1>;\n\n    mpcore-bus@19000000 {\n        compatible = "simple-bus";\n        ranges = <0x00000000 0x19000000 0x00023000>;\n        #address-cells = <1>;\n        #size-cells = <1>;\n    };\n};\n')])])]),s("p",[t._v("如上, 从父节点(即根节点)的 "),s("code",[t._v("#address-cells")]),t._v(" 和 "),s("code",[t._v("#size-cells")]),t._v(", 可以知道子节点定义时"),s("code",[t._v("address")]),t._v("和"),s("code",[t._v("length")]),t._v("都为1, 同理可以知道子节点(即mpcore-bus节点)的子节点定义时"),s("code",[t._v("address")]),t._v("也为1, 所以，对于上面的示例中, ranges 的 0x00000000 对应的是 mpcore-bus节点中 #address-cells=<1>, 0x19000000 对应的是父节点(即根节点)中的 #address-cells=<1>, 0x00023000 对应的是父节点(即根节点)中的 #size-cells = <1>, 这里的意思即 mpcore-bus 总线中, 从 0x00000000 地址空间开始的 0x00023000 个地址被映射到父地址空间的 0x19000000 开始的 0x00023000 个地址")]),t._v(" "),s("h3",{attrs:{id:"中断"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#中断"}},[t._v("#")]),t._v(" 中断")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('/ {\n    soc {\n        gicv2: interrupt-controller@40041000 {\n            interrupt-controller;\n            #interrupt-cells = <3>;\n            compatible = "arm,gic-400";\n            reg =   <0x40041000 0x1000>,\n                <0x40042000 0x2000>,\n                <0x40044000 0x2000>,\n                <0x40046000 0x2000>;\n            interrupts = <GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(4) |\n                         IRQ_TYPE_LEVEL_HIGH)>;\n        };\n    };\n};\n\n')])])]),s("p",[t._v("如上, 是在 bcm2711.dtsi 中定义的中断控制器")]),t._v(" "),s("h4",{attrs:{id:"interrupt-controller"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#interrupt-controller"}},[t._v("#")]),t._v(" interrupt-controller")]),t._v(" "),s("p",[t._v("这个属性用于表明该设备节点为一个中断控制器, 其属性值为空, 其组织形式一般为 "),s("code",[t._v("interrupt-controller;")])]),t._v(" "),s("h4",{attrs:{id:"interrupt-cells"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#interrupt-cells"}},[t._v("#")]),t._v(" #interrupt-cells")]),t._v(" "),s("p",[s("code",[t._v("#interrupt-cells")]),t._v("和"),s("code",[t._v("#address-cells")]),t._v("以及"),s("code",[t._v("#size-cells")]),t._v("类似，用于表明连接此中断控制器的设备的中断属性的"),s("code",[t._v("cell")]),t._v("大小, 即对应"),s("code",[t._v("interrupts")]),t._v("设备节点中的属性的大小")]),t._v(" "),s("p",[t._v("如示例中, "),s("code",[t._v("#interrupt-cells=<3>")]),t._v(", 则 "),s("code",[t._v("interrupts")]),t._v("中由三个属性值组成, 它们依次分别代表中断类型"),s("code",[t._v("GIC_PPI")]),t._v(", 中断号"),s("code",[t._v("9")]),t._v(", 中断触发方式和中断掩码"),s("code",[t._v("(GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)")])]),t._v(" "),s("h4",{attrs:{id:"interrupt-parent"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#interrupt-parent"}},[t._v("#")]),t._v(" #interrupt-parent")]),t._v(" "),s("p",[t._v("通过该设备节点指定它依附的中断控制器的 phandle, 当节点没有指定 interrupt-parent 时, 则从父节点继承")]),t._v(" "),s("h4",{attrs:{id:"interrupts"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#interrupts"}},[t._v("#")]),t._v(" interrupts")]),t._v(" "),s("p",[t._v("用到中断的设备节点, 通过该节点指示中断类型, 中断号, 以及中断触发方式等，由 "),s("code",[t._v("#interrupt-cells")]),t._v(" 控制具体包含几个"),s("code",[t._v("cell")])]),t._v(" "),s("h3",{attrs:{id:"gpio"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#gpio"}},[t._v("#")]),t._v(" GPIO")]),t._v(" "),s("p",[t._v("bcm2711-rpi.dtsi:")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('    expgpio: gpio {\n        compatible = "raspberrypi,firmware-gpio";\n        gpio-controller;\n        #gpio-cells = <2>;\n        status = "okay";\n    };\n')])])]),s("p",[t._v("bcm283x-rpi-led-deprecated.dtsi:")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('    leds: leds {\n        compatible = "gpio-leds";\n\n        led_act: led-act {\n            label = "ACT";\n            default-state = "keep";\n            linux,default-trigger = "heartbeat";\n        };\n    };\n')])])]),s("p",[t._v("bcm2711-rpi-4-b.dts:")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('&leds {\n    led_pwr: led-pwr {\n        label = "PWR";\n        gpios = <&expgpio 2 GPIO_ACTIVE_LOW>;\n        default-state = "keep";\n        linux,default-trigger = "default-on";\n    };\n};\n\n')])])]),s("h4",{attrs:{id:"gpio-controller"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#gpio-controller"}},[t._v("#")]),t._v(" gpio-controller")]),t._v(" "),s("p",[t._v("与 "),s("code",[t._v("interrupt-controller")]),t._v("类似,  用于表明该设备是一个gpio控制器, 如 "),s("code",[t._v("bcm2711-rpi.dtsi")]),t._v(" 文件中的示例")]),t._v(" "),s("h4",{attrs:{id:"gpio-cells"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#gpio-cells"}},[t._v("#")]),t._v(" #gpio-cells")]),t._v(" "),s("p",[t._v("与 "),s("code",[t._v("interrupt-cells")]),t._v("等类似, 用于控制 gpios 设备节点中 cell 的大小")]),t._v(" "),s("h4",{attrs:{id:"gpios"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#gpios"}},[t._v("#")]),t._v(" gpios")]),t._v(" "),s("p",[t._v("gpios 属性，用于指示某个 gpio 的初始属性, 由 #gpio-cells 控制 cell 的大小, 一般而言, "),s("code",[t._v("#gpio-cells=<2>")]),t._v(", 则对应的gpios的值代表的意思为: 第 1 值表示 gpio 号, 第 2 个值表示 gpio 的极性")]),t._v(" "),s("p",[t._v("如 "),s("code",[t._v("bcm2711-rpi-4-b.dts")]),t._v("文件中的示例, 其属性值的含义为: gpio2 低电平有效")]),t._v(" "),s("h3",{attrs:{id:"时钟"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#时钟"}},[t._v("#")]),t._v(" 时钟")]),t._v(" "),s("div",{staticClass:"language-dts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('    clk_27MHz: clk-27M {\n        #clock-cells = <0>;\n        compatible = "fixed-clock";\n        clock-frequency = <27000000>;\n        clock-output-names = "27MHz-clock";\n    };\n\n    clk_108MHz: clk-108M {\n        #clock-cells = <0>;\n        compatible = "fixed-clock";\n        clock-frequency = <108000000>;\n        clock-output-names = "108MHz-clock";\n    };\n')])])]),s("h4",{attrs:{id:"clock-cells"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#clock-cells"}},[t._v("#")]),t._v(" #clock-cells")]),t._v(" "),s("p",[t._v("与 "),s("code",[t._v("gpio-cells")]),t._v("类似, 用于指示 clocks 设备节点中 cell 的大小")]),t._v(" "),s("h4",{attrs:{id:"clock-frequency"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#clock-frequency"}},[t._v("#")]),t._v(" clock-frequency")]),t._v(" "),s("p",[t._v("时钟频率")]),t._v(" "),s("h3",{attrs:{id:"pinmux连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pinmux连接"}},[t._v("#")]),t._v(" pinmux连接")]),t._v(" "),s("p",[t._v("设备节点使用的 pinmux 的引脚群")]),t._v(" "),s("h4",{attrs:{id:"pinctrl-names"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pinctrl-names"}},[t._v("#")]),t._v(" pinctrl-names")]),t._v(" "),s("p",[t._v("引脚名")]),t._v(" "),s("h2",{attrs:{id:"设备树部分函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设备树部分函数"}},[t._v("#")]),t._v(" 设备树部分函数")]),t._v(" "),s("h3",{attrs:{id:"寻找节点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#寻找节点"}},[t._v("#")]),t._v(" 寻找节点")]),t._v(" "),s("h4",{attrs:{id:"of-find-compatible-node"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#of-find-compatible-node"}},[t._v("#")]),t._v(" of_find_compatible_node")]),t._v(" "),s("div",{attrs:{id:"of_find_compatible_node"}}),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/**\n * of_find_compatible_node - Find a node based on type and one of the\n *                                tokens in its "compatible" property\n * @from:   The node to start searching from or NULL, the node\n *      you pass will not be searched, only the next one\n *      will; typically, you pass what the previous call\n *      returned. of_node_put() will be called on it\n * @type:   The type string to match "device_type" or NULL to ignore\n * @compatible: The string to match to one of the tokens in the device\n *      "compatible" list.\n *\n * Return: A node pointer with refcount incremented, use\n * of_node_put() on it when done.\n */')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_find_compatible_node")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("from"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("type"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("compatible"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("如上, "),s("code",[t._v("of_find_compatible_node")]),t._v(" 函数用于根据兼容属性以及节点类型, 获取设备节点, 当from，type为空时, 表示遍历所有节点")]),t._v(" "),s("h4",{attrs:{id:"of-find-property"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#of-find-property"}},[t._v("#")]),t._v(" of_find_property")]),t._v(" "),s("div",{attrs:{id:"of_find_property"}}),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token macro-name function"}},[t._v("of_prop_cmp")]),s("span",{pre:!0,attrs:{class:"token expression"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" s2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("strcasecmp")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")])])]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("property")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("__of_find_property")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                       "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("lenp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("property")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("pp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" np"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("properties"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" pp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" pp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" pp"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("next"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_prop_cmp")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pp"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("lenp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("lenp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" pp"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" pp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("property")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_find_property")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("lenp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("property")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("pp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" flags"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("raw_spin_lock_irqsave")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("devtree_lock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" flags"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    pp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("__of_find_property")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" lenp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("raw_spin_unlock_irqrestore")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("devtree_lock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" flags"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" pp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("EXPORT_SYMBOL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("of_find_property"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h3",{attrs:{id:"读取属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#读取属性"}},[t._v("#")]),t._v(" 读取属性")]),t._v(" "),s("h4",{attrs:{id:"整型属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#整型属性"}},[t._v("#")]),t._v(" 整型属性")]),t._v(" "),s("p",[t._v("如下几个函数用于读取设备节点 np 下属性名为 propname，属性类型为8，16，32，64 位整型数组的值")]),t._v(" "),s("h5",{attrs:{id:"of-property-read-u8-array"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#of-property-read-u8-array"}},[t._v("#")]),t._v(" of_property_read_u8_array")]),t._v(" "),s("div",{attrs:{id:"of_property_read_u8_array"}}),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * of_property_read_u8_array - Find and read an array of u8 from a property.\n *\n * @np:     device node from which the property value is to be read.\n * @propname:   name of the property to be searched.\n * @out_values: pointer to return value, modified only if return value is 0.\n * @sz:     number of array elements to read\n *\n * Search for a property in a device node and read 8-bit value(s) from\n * it.\n *\n * dts entry of array should be like:\n *  ``property = /bits/ 8 <0x50 0x60 0x70>;``\n *\n * Return: 0 on success, -EINVAL if the property does not exist,\n * -ENODATA if property does not have a value, and -EOVERFLOW if the\n * property data isn't large enough.\n *\n * The out_values is modified only if a valid u8 value can be decoded.\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("inline")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_property_read_u8_array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("propname"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                        u8 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("out_values"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("size_t")]),t._v(" sz"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),s("p",[t._v("当数组大小为 1 时, 可以调用")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("inline")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_property_read_u8")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                       "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("propname"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                       u8 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("out_value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_property_read_u8_array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" propname"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" out_value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h5",{attrs:{id:"of-property-read-u16-array"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#of-property-read-u16-array"}},[t._v("#")]),t._v(" of_property_read_u16_array")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * of_property_read_u16_array - Find and read an array of u16 from a property.\n *\n * @np:     device node from which the property value is to be read.\n * @propname:   name of the property to be searched.\n * @out_values: pointer to return value, modified only if return value is 0.\n * @sz:     number of array elements to read\n *\n * Search for a property in a device node and read 16-bit value(s) from\n * it.\n *\n * dts entry of array should be like:\n *  ``property = /bits/ 16 <0x5000 0x6000 0x7000>;``\n *\n * Return: 0 on success, -EINVAL if the property does not exist,\n * -ENODATA if property does not have a value, and -EOVERFLOW if the\n * property data isn't large enough.\n *\n * The out_values is modified only if a valid u16 value can be decoded.\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("inline")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_property_read_u16_array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                         "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("propname"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                         u16 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("out_values"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("size_t")]),t._v(" sz"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("当数组大小为 1 时, 可以调用")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("inline")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_property_read_u16")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                       "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("propname"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                       u16 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("out_value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_property_read_u16_array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" propname"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" out_value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h5",{attrs:{id:"of-property-read-u32-array"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#of-property-read-u32-array"}},[t._v("#")]),t._v(" of_property_read_u32_array")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * of_property_read_u32_array - Find and read an array of 32 bit integers\n * from a property.\n *\n * @np:     device node from which the property value is to be read.\n * @propname:   name of the property to be searched.\n * @out_values: pointer to return value, modified only if return value is 0.\n * @sz:     number of array elements to read\n *\n * Search for a property in a device node and read 32-bit value(s) from\n * it.\n *\n * Return: 0 on success, -EINVAL if the property does not exist,\n * -ENODATA if property does not have a value, and -EOVERFLOW if the\n * property data isn't large enough.\n *\n * The out_values is modified only if a valid u32 value can be decoded.\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("inline")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_property_read_u32_array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                         "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("propname"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                         u32 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("out_values"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("size_t")]),t._v(" sz"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("当数组大小为 1 时, 可以调用")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("inline")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_property_read_u32")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                       "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("propname"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                       u32 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("out_value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_property_read_u32_array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" propname"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" out_value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h5",{attrs:{id:"of-property-read-u64-array"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#of-property-read-u64-array"}},[t._v("#")]),t._v(" of_property_read_u64_array")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * of_property_read_u64_array - Find and read an array of 64 bit integers\n * from a property.\n *\n * @np:     device node from which the property value is to be read.\n * @propname:   name of the property to be searched.\n * @out_values: pointer to return value, modified only if return value is 0.\n * @sz:     number of array elements to read\n *\n * Search for a property in a device node and read 64-bit value(s) from\n * it.\n *\n * Return: 0 on success, -EINVAL if the property does not exist,\n * -ENODATA if property does not have a value, and -EOVERFLOW if the\n * property data isn't large enough.\n *\n * The out_values is modified only if a valid u64 value can be decoded.\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("inline")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_property_read_u64_array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                         "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("propname"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                         u64 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("out_values"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("size_t")]),t._v(" sz"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("h4",{attrs:{id:"字符串属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字符串属性"}},[t._v("#")]),t._v(" 字符串属性")]),t._v(" "),s("p",[t._v("如下几个函数用于读取设备节点 np 下属性名为 propname，字符串类型的值")]),t._v(" "),s("h5",{attrs:{id:"of-property-read-string"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#of-property-read-string"}},[t._v("#")]),t._v(" of_property_read_string")]),t._v(" "),s("div",{attrs:{id:"of_property_read_string"}}),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/**\n * of_property_read_string - Find and read a string from a property\n * @np:     device node from which the property value is to be read.\n * @propname:   name of the property to be searched.\n * @out_string: pointer to null terminated return string, modified only if\n *      return value is 0.\n *\n * Search for a property in a device tree node and retrieve a null\n * terminated string value (pointer to data, not a copy).\n *\n * Return: 0 on success, -EINVAL if the property does not exist, -ENODATA if\n * property does not have a value, and -EILSEQ if the string is not\n * null-terminated within the length of the property data.\n *\n * Note that the empty string "" has length of 1, thus -ENODATA cannot\n * be interpreted as an empty string.\n *\n * The out_string pointer is modified only if a valid string can be decoded.\n */')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_property_read_string")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("propname"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("out_string"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("如上, 是读取 np 设备节点下属性名为 propname 的设备节点的字符串属性值")]),t._v(" "),s("h4",{attrs:{id:"of-property-read-string-index"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#of-property-read-string-index"}},[t._v("#")]),t._v(" of_property_read_string_index")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * of_property_read_string_index() - Find and read a string from a multiple\n * strings property.\n * @np:     device node from which the property value is to be read.\n * @propname:   name of the property to be searched.\n * @index:  index of the string in the list of strings\n * @output: pointer to null terminated return string, modified only if\n *      return value is 0.\n *\n * Search for a property in a device tree node and retrieve a null\n * terminated string value (pointer to data, not a copy) in the list of strings\n * contained in that property.\n *\n * Return: 0 on success, -EINVAL if the property does not exist, -ENODATA if\n * property does not have a value, and -EILSEQ if the string is not\n * null-terminated within the length of the property data.\n *\n * The out_string pointer is modified only if a valid string can be decoded.\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("inline")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_property_read_string_index")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("propname"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("output"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("如上, 是读取 np 设备节点下属性名为 propname 的设备节点字符串数组的第 index 个属性值")]),t._v(" "),s("h4",{attrs:{id:"布尔值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#布尔值"}},[t._v("#")]),t._v(" 布尔值")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * of_property_read_bool - Find a property\n * @np:     device node from which the property value is to be read.\n * @propname:   name of the property to be searched.\n *\n * Search for a boolean property in a device node. Usage on non-boolean\n * property types is deprecated.\n *\n * Return: true if the property exists false otherwise.\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("inline")]),t._v(" bool "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_property_read_bool")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("propname"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("如上, 是检查 np 设备节点下是否含有属性名为 propname 的设备节点, 有则返回true, 否则返回false")]),t._v(" "),s("h3",{attrs:{id:"内存映射"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存映射"}},[t._v("#")]),t._v(" 内存映射")]),t._v(" "),s("h4",{attrs:{id:"of-iomap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#of-iomap"}},[t._v("#")]),t._v(" of_iomap")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" __iomem "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_iomap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("如上, 是通过设备节点进行设备内存区间的 ioremap(), index 是内存段的索引, 若设备节点的 reg 属性由多端时, 可通过 index 标示要 ioremap() 的是哪一段, 在只有 1 段的情况下, index 为0")]),t._v(" "),s("h4",{attrs:{id:"of-address-to-resource"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#of-address-to-resource"}},[t._v("#")]),t._v(" of_address_to_resource")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_address_to_resource")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n               "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("resource")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("r"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("如上, 通过设备节点获取与它对应的内存资源的 resource 结构体, 其本质是分析 reg 属性以获取内存基地址、大小等信息并填充到 struct resource *r 参数指向的结构体中")]),t._v(" "),s("h3",{attrs:{id:"解析中断"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解析中断"}},[t._v("#")]),t._v(" 解析中断")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * irq_of_parse_and_map - Parse and map an interrupt into linux virq space\n * @dev: Device node of the device whose interrupt is to be mapped\n * @index: Index of the interrupt to map\n *\n * This function is a wrapper that chains of_irq_parse_one() and\n * irq_create_of_mapping() to make things easier to callers\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("irq_of_parse_and_map")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("dev"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("如上, 通过设备树获取设备的中断号，实际上是从 .dts 中的 interrupts 属性里解析出中断号, 若设备使用了多个中断, index 指定中断的索引号")]),t._v(" "),s("h3",{attrs:{id:"获取与节点对应的-platform-device"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#获取与节点对应的-platform-device"}},[t._v("#")]),t._v(" 获取与节点对应的 platform_device")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * of_find_device_by_node - Find the platform_device associated with a node\n * @np: Pointer to device tree node\n *\n * Takes a reference to the embedded struct device which needs to be dropped\n * after use.\n *\n * Return: platform_device pointer, or NULL if not found\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("platform_device")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_find_device_by_node")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("如上, 通过设备节点其获取对应的 platform_device 设备")]),t._v(" "),s("h3",{attrs:{id:"其他of-api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其他of-api"}},[t._v("#")]),t._v(" 其他of api")]),t._v(" "),s("h4",{attrs:{id:"of-get-named-gpio"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#of-get-named-gpio"}},[t._v("#")]),t._v(" of_get_named_gpio")]),t._v(" "),s("div",{attrs:{id:"of_get_named_gpio"}}),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * of_get_named_gpio() - Get a GPIO number to use with GPIO API\n * @np:     device node to get GPIO from\n * @propname:   Name of property containing gpio specifier(s)\n * @index:  index of the GPIO\n *\n * Returns GPIO number to use with Linux generic GPIO API, or one of the errno\n * value on the error condition.\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_get_named_gpio")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("propname"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n              "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),s("p",[t._v("如上, 是获取 np 设备节点下, 名为 propname 的子设备节点中第 index 个索引的 gpio 设备节点属性值")]),t._v(" "),s("h4",{attrs:{id:"platform-get-irq"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#platform-get-irq"}},[t._v("#")]),t._v(" platform_get_irq")]),t._v(" "),s("div",{attrs:{id:"platform_get_irq"}}),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * platform_get_irq - get an IRQ for a device\n * @dev: platform device\n * @num: IRQ number index\n *\n * Gets an IRQ for a platform device and prints an error message if finding the\n * IRQ fails. Device drivers should check the return value for errors so as to\n * not pass a negative integer value to the request_irq() APIs.\n *\n * For example::\n *\n *      int irq = platform_get_irq(pdev, 0);\n *      if (irq < 0)\n *          return irq;\n *\n * Return: non-zero IRQ number on success, negative error number on failure.\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("platform_get_irq")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("platform_device")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("dev"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" num"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" ret"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    ret "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("platform_get_irq_optional")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("dev"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" num"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ret "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("dev_err_probe")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("dev"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("dev"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ret"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                     "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"IRQ index %u not found\\n"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" num"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" ret"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("EXPORT_SYMBOL_GPL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("platform_get_irq"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("如上, 是获取 dev 设备的第 index 个中断")]),t._v(" "),s("h4",{attrs:{id:"of-machine-is-compatible"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#of-machine-is-compatible"}},[t._v("#")]),t._v(" of_machine_is_compatible")]),t._v(" "),s("div",{attrs:{id:"of_machine_is_compatible"}}),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * of_machine_is_compatible - Test root of device tree for a given compatible value\n * @compat: compatible string to look for in root node's compatible property.\n *\n * Return: A positive integer if the root node has the given value in its\n * compatible property.\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_machine_is_compatible")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("compat"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" rc "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    root "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_find_node_by_path")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        rc "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_device_is_compatible")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" compat"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_node_put")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" rc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("EXPORT_SYMBOL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("of_machine_is_compatible"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("该函数用于判断目前运行的板子或 SoC 的兼容性, 即匹配设备树根节点下的兼容属性 compatible 对应的属性值是否匹配 compat 指定的字符串(即字符串值是否相等)")]),t._v(" "),s("h4",{attrs:{id:"of-device-compatible-match"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#of-device-compatible-match"}},[t._v("#")]),t._v(" of_device_compatible_match")]),t._v(" "),s("div",{attrs:{id:"of_device_compatible_match"}}),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/** Checks if the device is compatible with any of the entries in\n *  a NULL terminated array of strings. Returns the best match\n *  score or 0.\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_device_compatible_match")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("device"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("compat"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" tmp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" score "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("compat"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("compat"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        tmp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_device_is_compatible")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("device"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("compat"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("tmp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" score"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            score "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" tmp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        compat"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" score"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("EXPORT_SYMBOL_GPL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("of_device_compatible_match"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("该函数用于判断设备节点的兼容性, 即匹配设备节点下的兼容属性 compatible 对应的属性值是否匹配 compat 指定的字符串(即字符串值是否相等)")]),t._v(" "),s("h4",{attrs:{id:"of-prop-next-string"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#of-prop-next-string"}},[t._v("#")]),t._v(" of_prop_next_string")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_prop_next_string")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("property")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("prop"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("cur"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("curv "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" cur"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("prop"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("cur"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" prop"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    curv "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("strlen")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("cur"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("curv "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" prop"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("value "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" prop"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" curv"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("EXPORT_SYMBOL_GPL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("of_prop_next_string"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h4",{attrs:{id:"of-find-node-by-type"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#of-find-node-by-type"}},[t._v("#")]),t._v(" of_find_node_by_type")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" bool "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("__of_node_is_type")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("type"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("match "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("__of_get_property")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"device_type"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" np "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" match "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" type "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("strcmp")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("match"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" type"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/**\n * of_find_node_by_type - Find a node by its "device_type" property\n * @from:   The node to start searching from, or NULL to start searching\n *      the entire device tree. The node you pass will not be\n *      searched, only the next one will; typically, you pass\n *      what the previous call returned. of_node_put() will be\n *      called on from for you.\n * @type:   The type string to match against\n *\n * Return: A node pointer with refcount incremented, use\n * of_node_put() on it when done.\n */')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_find_node_by_type")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("from"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("type"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" flags"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("raw_spin_lock_irqsave")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("devtree_lock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" flags"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("for_each_of_allnodes_from")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("from"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("__of_node_is_type")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" type"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_node_get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_node_put")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("from"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("raw_spin_unlock_irqrestore")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("devtree_lock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" flags"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("EXPORT_SYMBOL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("of_find_node_by_type"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h4",{attrs:{id:"of-node-name-eq"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#of-node-name-eq"}},[t._v("#")]),t._v(" of_node_name_eq")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[t._v("bool "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_node_name_eq")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("node_name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("size_t")]),t._v(" len"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" false"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    node_name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("kbasename")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("np"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("full_name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    len "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("strchrnul")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node_name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token char"}},[t._v("'@'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" node_name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("strlen")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" len"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("strncmp")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node_name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" len"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("EXPORT_SYMBOL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("of_node_name_eq"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),s("h2",{attrs:{id:"基于设备树的设备和驱动的匹配"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基于设备树的设备和驱动的匹配"}},[t._v("#")]),t._v(" 基于设备树的设备和驱动的匹配")]),t._v(" "),s("h3",{attrs:{id:"of-driver-match-device"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#of-driver-match-device"}},[t._v("#")]),t._v(" of_driver_match_device")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * of_match_device - Tell if a struct device matches an of_device_id list\n * @matches: array of of device match structures to search in\n * @dev: the of device structure to match against\n *\n * Used by a driver to check whether an platform_device present in the\n * system is in its list of supported devices.\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("of_device_id")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_match_device")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("of_device_id")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("matches"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                       "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("dev"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("matches "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("dev"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("of_node "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" dev"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("of_node_reused"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_match_node")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("matches"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" dev"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("of_node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("EXPORT_SYMBOL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("of_match_device"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * of_driver_match_device - Tell if a driver's of_match_table matches a device.\n * @drv: the device_driver structure to test\n * @dev: the device structure to match against\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("inline")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_driver_match_device")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("dev"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_driver")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("drv"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_match_device")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("drv"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("of_match_table"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" dev"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("正如"),s("RouterLink",{attrs:{to:"/driver/platform/match.html"}},[t._v("platform设备的匹配")]),t._v("中描述的那样, 基于设备树的设备和驱动的匹配通过 of_driver_match_device 进行, 而 of_driver_match_device 函数通过调用 of_match_device 进行匹配, 它们的实现如上, 可以看出基于设备树的设备和驱动的匹配就是设备的 of_node (设备树节点)和驱动的 of_match_table 之间的匹配")],1),t._v(" "),s("p",[t._v("其中 of_match_table 是驱动的匹配表, 驱动这个表判断是否匹配设备(即是否能够驱动这个设备), 其内容形式一般如下(参考drivers/spi/spidev.c文件):")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("of_device_id")]),t._v(" spidev_dt_ids"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("compatible "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"cisco,spi-petra"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("spidev_of_check "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("compatible "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"dh,dhcom-board"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("spidev_of_check "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("compatible "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"lineartechnology,ltc2488"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("spidev_of_check "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("compatible "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"lwn,bk4"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("spidev_of_check "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("compatible "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"menlo,m53cpld"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("spidev_of_check "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("compatible "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"micron,spi-authenta"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("spidev_of_check "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("compatible "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"rohm,dh2228fv"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("spidev_of_check "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("compatible "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"semtech,sx1301"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("spidev_of_check "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("compatible "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"silabs,em3581"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("spidev_of_check "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("compatible "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"silabs,si3210"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("spidev_of_check "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("MODULE_DEVICE_TABLE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("of"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" spidev_dt_ids"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("注意其中的 .compatible 字段，在进行设备匹配的时候将用到")]),t._v(" "),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"title"},[t._v("注意")]),s("p",[t._v("从 __of_match_node 函数的具体实现, 不难发现 of_match_table 匹配表数组中, 最后的 {} 是必须的, 因为 __of_match_node 通过它来判断数组的结束")])]),s("h3",{attrs:{id:"of-match-node"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#of-match-node"}},[t._v("#")]),t._v(" of_match_node")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * of_match_node - Tell if a device_node has a matching of_match structure\n * @matches:    array of of device match structures to search in\n * @node:   the of device structure to match against\n *\n * Low level utility function used by device matching.\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("of_device_id")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_match_node")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("of_device_id")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("matches"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("of_device_id")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("match"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" flags"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("raw_spin_lock_irqsave")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("devtree_lock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" flags"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    match "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("__of_match_node")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("matches"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("raw_spin_unlock_irqrestore")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("devtree_lock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" flags"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" match"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("EXPORT_SYMBOL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("of_match_node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("如上, 通过设备的of_match_table表判断是否匹配设备树的设备节点")]),t._v(" "),s("h3",{attrs:{id:"of-match-node-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#of-match-node-2"}},[t._v("#")]),t._v(" __of_match_node")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("of_device_id")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("__of_match_node")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("of_device_id")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("matches"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                       "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("of_device_id")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("best_match "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" score"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" best_score "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("matches"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" matches"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" matches"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("type"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" matches"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("compatible"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" matches"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        score "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("__of_device_is_compatible")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" matches"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("compatible"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                          matches"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("type"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" matches"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("score "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" best_score"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            best_match "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" matches"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            best_score "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" score"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" best_match"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("如上, __of_match_node 函数遍历 of_match_table 和设备树节点 node 进行比较, 找到最佳匹配结果")]),t._v(" "),s("h3",{attrs:{id:"of-device-is-compatible"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#of-device-is-compatible"}},[t._v("#")]),t._v(" __of_device_is_compatible")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token macro-name function"}},[t._v("of_compat_cmp")]),s("span",{pre:!0,attrs:{class:"token expression"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" s2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" l"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("strncmp")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("l"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")])])]),t._v("\n\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/**\n * __of_device_is_compatible() - Check if the node matches given constraints\n * @device: pointer to node\n * @compat: required compatible string, NULL or "" for any match\n * @type: required device_type value, NULL or "" for any match\n * @name: required node name, NULL or "" for any match\n *\n * Checks if the given @compat, @type and @name strings match the\n * properties of the given @device. A constraints can be skipped by\n * passing NULL or an empty string as the constraint.\n *\n * Returns 0 for no match, and a positive integer on match. The return\n * value is a relative score with larger values indicating better\n * matches. The score is weighted for the most specific compatible value\n * to get the highest score. Matching type is next, followed by matching\n * name. Practically speaking, this results in the following priority\n * order for matches:\n *\n * 1. specific compatible && type && name\n * 2. specific compatible && type\n * 3. specific compatible && name\n * 4. specific compatible\n * 5. general compatible && type && name\n * 6. general compatible && type\n * 7. general compatible && name\n * 8. general compatible\n * 9. type && name\n * 10. type\n * 11. name\n */')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("__of_device_is_compatible")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("device_node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("device"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("compat"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("type"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("property")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("prop"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("cp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" index "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" score "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Compatible match has highest priority */")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("compat "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" compat"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        prop "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("__of_find_property")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("device"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"compatible"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("cp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_prop_next_string")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("prop"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" cp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n             cp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_prop_next_string")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("prop"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" cp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" index"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_compat_cmp")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("cp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" compat"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("strlen")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("compat"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                score "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" INT_MAX"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("index "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("score"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Matching type is better than matching name */")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("type "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" type"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("__of_node_is_type")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("device"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" type"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        score "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Matching name is a bit better than not */")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of_node_name_eq")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("device"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        score"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" score"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("如上, __of_device_is_compatible 函数进行设备节点兼容性的匹配, 不匹配的时候, 返回0, 否则返回大于0的值(值越大匹配度越小)")]),t._v(" "),s("p",[t._v("从函数实现上看, 匹配分为三部分")]),t._v(" "),s("p",[t._v("(1) 匹配设备树中的 .compatible 兼容性属性")]),t._v(" "),s("p",[t._v("这里通过 for 循环和 of_prop_next_string 函数遍历 .compatible 兼容性属性")]),t._v(" "),s("p",[t._v("因为 .compatible 可能是包含多个属性值, 在这里匹配的 .compatible 属性值越是后面, 匹配分值越高(意味着匹配度越低)")]),t._v(" "),s("p",[t._v("(2) 匹配设备树中 .device_type 设备类型属性")]),t._v(" "),s("p",[t._v("(3) 匹配设备树设备节点名")])])}),[],!1,null,null,null);s.default=e.exports}}]);