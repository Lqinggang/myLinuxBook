(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{439:function(t,a,s){"use strict";s.r(a);var e=s(2),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"i2c-核心"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#i2c-核心"}},[t._v("#")]),t._v(" I2C 核心")]),t._v(" "),a("p",[t._v("I2C 核心提供了一组不依赖与硬件平台的接口函数,  I2C 总线驱动和设备驱动之间以 I2C 核心作为纽带")]),t._v(" "),a("h2",{attrs:{id:"增加-删除-i2c-adapter"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#增加-删除-i2c-adapter"}},[t._v("#")]),t._v(" 增加/删除 i2c_adapter")]),t._v(" "),a("h3",{attrs:{id:"i2c-add-adapter"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#i2c-add-adapter"}},[t._v("#")]),t._v(" i2c_add_adapter")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * i2c_add_adapter - declare i2c adapter, use dynamic bus number\n * @adapter: the adapter to add\n * Context: can sleep\n *\n * This routine is used to declare an I2C adapter when its bus number\n * doesn't matter or when its bus number is specified by an dt alias.\n * Examples of bases when the bus number doesn't matter: I2C adapters\n * dynamically added by USB links or PCI plugin cards.\n *\n * When this returns zero, a new bus number was allocated and stored\n * in adap->nr, and the specified adapter became available for clients.\n * Otherwise, a negative errno value is returned.\n */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("i2c_add_adapter")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("i2c_adapter")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("adapter"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("如上, 通过 i2c_add_adapter 函数定义和注册一个 i2c_adapter")]),t._v(" "),a("h3",{attrs:{id:"i2c-del-adapter"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#i2c-del-adapter"}},[t._v("#")]),t._v(" i2c_del_adapter")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * i2c_del_adapter - unregister I2C adapter\n * @adap: the adapter being unregistered\n * Context: can sleep\n *\n * This unregisters an I2C adapter which was previously registered\n * by @i2c_add_adapter or @i2c_add_numbered_adapter.\n */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("i2c_del_adapter")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("i2c_adapter")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("adap"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("如上, 通过 i2c_del_adapter 去注册一个 i2c_adapter")]),t._v(" "),a("h2",{attrs:{id:"增加-删除-i2c-driver"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#增加-删除-i2c-driver"}},[t._v("#")]),t._v(" 增加/删除 i2c_driver")]),t._v(" "),a("h3",{attrs:{id:"i2c-register-driver"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#i2c-register-driver"}},[t._v("#")]),t._v(" i2c_register_driver")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*\n * An i2c_driver is used with one or more i2c_client (device) nodes to access\n * i2c slave chips, on a bus instance associated with some i2c_adapter.\n */")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("i2c_register_driver")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("module")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("owner"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("i2c_driver")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("driver"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("如上, 通过 i2c_register_driver 函数注册一个 i2c 驱动, 这里需要指定所属的 module")]),t._v(" "),a("h3",{attrs:{id:"i2c-add-driver"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#i2c-add-driver"}},[t._v("#")]),t._v(" i2c_add_driver")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* use a define to avoid include chaining to get THIS_MODULE */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token macro-name function"}},[t._v("i2c_add_driver")]),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("driver"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" ")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("i2c_register_driver")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("THIS_MODULE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" driver"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")])])]),t._v("\n")])])]),a("p",[t._v("如上, 通过 i2c_add_driver 函数注册一个 i2c 驱动")]),t._v(" "),a("h3",{attrs:{id:"i2c-del-driver"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#i2c-del-driver"}},[t._v("#")]),t._v(" i2c_del_driver")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * i2c_del_driver - unregister I2C driver\n * @driver: the driver being unregistered\n * Context: can sleep\n */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("i2c_del_driver")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("i2c_driver")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("driver"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("如上， i2c_del_driver 用于删除一个 i2c 驱动")]),t._v(" "),a("h2",{attrs:{id:"i2c传输、发送和接收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#i2c传输、发送和接收"}},[t._v("#")]),t._v(" I2C传输、发送和接收")]),t._v(" "),a("h3",{attrs:{id:"i2c-transfer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#i2c-transfer"}},[t._v("#")]),t._v(" i2c_transfer")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * i2c_transfer - execute a single or combined I2C message\n * @adap: Handle to I2C bus\n * @msgs: One or more messages to execute before STOP is issued to\n *  terminate the operation; each message begins with a START.\n * @num: Number of messages to be executed.\n *\n * Returns negative errno, else the number of messages executed.\n *\n * Note that there is no requirement that each message be sent to\n * the same slave address, although that is the most common model.\n */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("i2c_transfer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("i2c_adapter")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("adap"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("i2c_msg")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("msgs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" num"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("如上, 用于I2C适配器和I2C设备之间的一组消息的交互, i2c_master_send 和 i2c_msater_recv 最终都是通过这个函数实现")]),t._v(" "),a("p",[t._v("i2c_transfer 函数本身不具有驱动适配器物理硬件以完成消息交互的能力, 它只是寻找到与 i2c_adapter 对应的 i2c_algorithm， 并使用 i2c_algorithm 的 master_xfer 函数真正驱动硬件的流程")]),t._v(" "),a("h3",{attrs:{id:"i2c-master-send"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#i2c-master-send"}},[t._v("#")]),t._v(" i2c_master_send")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * i2c_master_send - issue a single I2C message in master transmit mode\n * @client: Handle to slave device\n * @buf: Data that will be written to the slave\n * @count: How many bytes to write, must be less than 64k since msg.len is u16\n *\n * Returns negative errno, or else the number of bytes written.\n */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("inline")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("i2c_master_send")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("i2c_client")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("client"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("buf"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("i2c_transfer_buffer_flags")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("client"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("buf"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("如上, 用于向 I2C 从设备发送一个消息")]),t._v(" "),a("h3",{attrs:{id:"i2c-master-recv"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#i2c-master-recv"}},[t._v("#")]),t._v(" i2c_master_recv")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * i2c_master_recv - issue a single I2C message in master receive mode\n * @client: Handle to slave device\n * @buf: Where to store data read from slave\n * @count: How many bytes to read, must be less than 64k since msg.len is u16\n *\n * Returns negative errno, or else the number of bytes read.\n */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("inline")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("i2c_master_recv")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("i2c_client")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("client"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("buf"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("i2c_transfer_buffer_flags")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("client"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" buf"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" I2C_M_RD"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("如上, 用于从 I2C 从设备接收一个消息")])])}),[],!1,null,null,null);a.default=n.exports}}]);